# 3. MCP 통신 방식 (Transport)

[← 목차로 돌아가기](./0.목차.md) | [← 이전: 핵심기능](./2.핵심기능.md)

---

## 3.1 JSON-RPC 2.0 기반

MCP의 모든 통신은 JSON-RPC 2.0 형식을 따릅니다.

```json
// 요청 (Request)
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "method": "tools/call",
  "params": {
    "name": "create_jira_issue",
    "arguments": { "project": "ABC", "summary": "버그 수정" }
  }
}

// 응답 (Response) - 성공
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "result": {
    "content": [{ "type": "text", "text": "이슈 ABC-123 생성됨" }]
  }
}

// 응답 (Response) - 실패
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "error": {
    "code": -32600,
    "message": "권한이 없습니다",
    "data": { "required_role": "ADMIN" }
  }
}
```

---

### 3.1.1 요청(Request) 필드 상세

| 필드 | 필수 | 타입 | 규칙 | 설명 |
|------|------|------|------|------|
| `jsonrpc` | ✅ | string | 항상 `"2.0"` | JSON-RPC 버전 (고정값) |
| `id` | ✅ | string \| number | 클라이언트가 자유롭게 생성 | 요청-응답 매칭용 고유 식별자 |
| `method` | ✅ | string | **MCP 표준에 정의된 값만** | 호출할 작업 종류 |
| `params` | ❌ | object | 메서드마다 다름 | 메서드에 필요한 파라미터 |

---

### 3.1.2 `id` 필드 - 클라이언트가 자유롭게 생성

**용도:** 요청을 보내고 → 응답을 받을 때 "어떤 요청에 대한 응답인지" 매칭

```json
// 모두 유효한 id 예시
{ "id": "req-001" }              // 문자열
{ "id": 12345 }                  // 숫자
{ "id": "abc-def-ghi-123" }      // UUID 스타일
{ "id": "user_1_tool_call_3" }   // 의미 있는 문자열
```

| 규칙 | 설명 |
|------|------|
| 타입 | 문자열 또는 숫자 |
| 고유성 | 같은 세션 내에서 중복되면 안 됨 |
| 생성 주체 | 클라이언트(Claude, Cursor 등)가 생성 |

---

### 3.1.3 `method` 필드 - MCP 표준에 정의됨

**`method`는 마음대로 만들 수 없고, MCP 프로토콜에서 정해진 값만 사용합니다.**

#### 주요 MCP 표준 메서드

| 카테고리 | 메서드 | 설명 |
|----------|--------|------|
| **초기화** | `initialize` | 클라이언트-서버 연결 시작 |
| | `initialized` | 초기화 완료 알림 (Notification) |
| **도구** | `tools/list` | 사용 가능한 도구 목록 조회 |
| | `tools/call` | 도구 실행 |
| **리소스** | `resources/list` | 리소스 목록 조회 |
| | `resources/read` | 리소스 내용 읽기 |
| | `resources/subscribe` | 리소스 변경 구독 |
| **프롬프트** | `prompts/list` | 프롬프트 템플릿 목록 |
| | `prompts/get` | 프롬프트 템플릿 가져오기 |
| **유틸리티** | `ping` | 연결 상태 확인 |
| | `logging/setLevel` | 로그 레벨 설정 |
| | `completion/complete` | 자동완성 제안 |

#### 왜 method는 표준화되어 있을까?

```
✅ 표준화된 method
   → 모든 MCP 서버가 같은 방식으로 동작
   → Claude가 "tools/list 보내면 도구 목록 온다"를 알고 있음
   → 호환성 보장!

❌ 만약 자유롭다면
   → Jira는 "getTools", GitHub는 "listTools", Slack은 "fetchTools"...
   → Claude가 각 서버별로 다 외워야 함
   → 혼란!
```

---

### 3.1.4 응답(Response) 필드 상세

**성공 응답:**

| 필드 | 필수 | 타입 | 설명 |
|------|------|------|------|
| `jsonrpc` | ✅ | string | 항상 `"2.0"` |
| `id` | ✅ | string \| number | 요청의 id와 동일해야 함 |
| `result` | ✅ | any | 성공 결과 데이터 |

**실패 응답:**

| 필드 | 필수 | 타입 | 설명 |
|------|------|------|------|
| `jsonrpc` | ✅ | string | 항상 `"2.0"` |
| `id` | ✅ | string \| number | 요청의 id와 동일해야 함 |
| `error` | ✅ | object | 에러 정보 |
| `error.code` | ✅ | number | 에러 코드 (표준 코드 존재) |
| `error.message` | ✅ | string | 에러 메시지 |
| `error.data` | ❌ | any | 추가 에러 정보 |

#### 표준 에러 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| `-32700` | Parse error | JSON 파싱 실패 |
| `-32600` | Invalid Request | 잘못된 요청 형식 |
| `-32601` | Method not found | 존재하지 않는 메서드 |
| `-32602` | Invalid params | 잘못된 파라미터 |
| `-32603` | Internal error | 서버 내부 오류 |

---

### 3.1.5 실제 통신 흐름 예시

```
┌─────────────────────────────────────────────────────────────────┐
│                    MCP 세션 시작 시 통신 흐름                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Claude Desktop                          MCP Server            │
│       │                                       │                 │
│       │──── initialize ──────────────────────▶│ "안녕, 난 Claude"│
│       │◀─── initialize 응답 ─────────────────│ "난 Jira 서버"   │
│       │                                       │                 │
│       │──── initialized (알림) ──────────────▶│ "준비 완료!"    │
│       │                                       │                 │
│       │──── tools/list ──────────────────────▶│ "뭐 할 수 있어?"│
│       │◀─── tools 목록 응답 ─────────────────│ "이슈 생성, 조회"│
│       │                                       │                 │
│       │──── tools/call ──────────────────────▶│ "이슈 만들어줘" │
│       │◀─── 실행 결과 ───────────────────────│ "ABC-123 생성됨"│
│       │                                       │                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.2 Transport 종류

### Transport란?

**Transport**는 "데이터를 어떻게 주고받을지"를 정하는 통신 방식입니다. 

비유하자면:
- **JSON-RPC** = "편지의 양식" (내용을 어떤 형식으로 쓸지)
- **Transport** = "배송 수단" (편지를 어떻게 전달할지 - 직접 전달? 우체국? 이메일?)

MCP에서는 두 가지 Transport 방식을 지원합니다:

| Transport | 설명 | 사용 사례 |
|-----------|------|-----------|
| **stdio** | 표준 입출력 (프로세스 통신) | 로컬 MCP 서버 (Cursor, Claude Desktop) |
| **Streamable HTTP** | HTTP POST + SSE 스트리밍 | 원격 MCP 서버 (MCPHUB) |

---

### 3.2.1 stdio (Standard Input/Output)

**stdio**는 컴퓨터 프로그램의 가장 기본적인 입출력 방식입니다.

```
터미널에서 실행하는 것과 같은 원리:
$ echo "안녕하세요"     ← 표준 입력(stdin)으로 명령어 입력
안녕하세요              ← 표준 출력(stdout)으로 결과 출력
```

**MCP에서 stdio 동작 방식:**

```
┌──────────────────┐         ┌──────────────────┐
│  Claude Desktop  │         │   MCP Server     │
│   (클라이언트)    │         │   (Node.js 등)   │
├──────────────────┤         ├──────────────────┤
│                  │──stdin──▶│ 요청 수신        │
│ JSON-RPC 요청    │         │ 처리             │
│                  │◀─stdout─│ JSON-RPC 응답    │
└──────────────────┘         └──────────────────┘
      같은 컴퓨터 안에서 프로세스끼리 직접 대화
```

1. Claude Desktop이 MCP 서버를 **자식 프로세스**로 실행 (`spawn`)
2. Claude → MCP 서버: **stdin**(표준 입력)으로 JSON-RPC 요청 전송
3. MCP 서버 → Claude: **stdout**(표준 출력)으로 JSON-RPC 응답 반환

**장점:**
- 🚀 매우 빠름 (네트워크 없이 메모리로 직접 통신)
- 🔧 설정이 간단함 (별도 서버 구축 불필요)
- 🔒 로컬에서만 동작하므로 보안 걱정 적음

**단점:**
- 🏠 같은 컴퓨터에서만 사용 가능
- 🖥️ 서버를 사용자 PC에 직접 설치해야 함

---

### 3.2.2 Streamable HTTP (HTTP + SSE)

원격 서버와 통신할 때 사용하는 방식입니다.

**핵심 개념:**

**HTTP POST** - 요청 보내기
```
클라이언트 → 서버: "이 작업 해주세요" (요청)
```

**SSE (Server-Sent Events)** - 응답 스트리밍
```
서버 → 클라이언트: "결과 1..." → "결과 2..." → "완료!" (실시간 스트림)
```

일반 HTTP는 요청-응답이 1:1이지만, SSE를 쓰면 서버가 **여러 번에 걸쳐** 데이터를 보낼 수 있습니다.

**왜 SSE가 필요할까요?**

LLM 응답은 시간이 오래 걸릴 수 있습니다. SSE를 사용하면:
```
❌ SSE 없이: [로딩... 로딩... 10초 후] "전체 응답 한꺼번에"
✅ SSE 사용: "응"→"답"→"이"→"실"→"시"→"간"→"으"→"로"→"옵니다" (타이핑 효과)
```

**MCP에서 Streamable HTTP 동작 방식:**

```
┌──────────────────┐                      ┌──────────────────┐
│     브라우저      │      인터넷          │   원격 MCP 서버   │
│   (클라이언트)    │                      │   (MCPHUB 등)    │
├──────────────────┤                      ├──────────────────┤
│                  │───HTTP POST 요청────▶│ 요청 수신        │
│ JSON-RPC 요청    │                      │ 처리 중...       │
│                  │◀──SSE 스트림────────│ 실시간 응답      │
│ 실시간 응답 수신  │◀──SSE 스트림────────│ 추가 데이터      │
│                  │◀──SSE 완료──────────│ 완료             │
└──────────────────┘                      └──────────────────┘
        네트워크를 통해 어디서든 접근 가능
```

**장점:**
- 🌐 인터넷만 되면 어디서든 사용 가능
- 📱 웹 브라우저, 모바일 앱 등 다양한 클라이언트 지원
- ⚡ SSE로 실시간 스트리밍 가능

**단점:**
- 🔐 인증/인가 처리 필요 (누가 접근하는지 확인)
- 🛠️ 서버 구축 및 운영 필요
- 🐌 네트워크 지연 발생 가능

---

### 3.2.3 언제 어떤 것을 쓸까?

```
┌─────────────────────────────────────────────────────────────────┐
│                     상황별 Transport 선택                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   "내 PC에서만 쓸 거야" (개인 개발 환경)                          │
│   ──────────────────────────────────────                        │
│   → stdio 사용                                                  │
│   → Cursor나 Claude Desktop에 MCP 서버 연결                     │
│                                                                 │
│   "팀원들과 같이 쓸 거야" (팀/조직 환경)                          │
│   ──────────────────────────────────────                        │
│   → Streamable HTTP 사용                                        │
│   → 중앙 서버에 MCP 서버 배포 (MCPHUB)                           │
│   → 인증/권한 관리 필요                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### 3.2.4 시각적 비교

```
┌─────────────────────────────────────────────────────────────────┐
│                     Transport 비교                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   [stdio 방식]                                                  │
│   Claude Desktop ─── (프로세스 spawn) ─── MCP Server (로컬)     │
│   - 빠름, 설정 간단                                             │
│   - 로컬 환경에서만 동작                                        │
│                                                                 │
│   [Streamable HTTP 방식]                                        │
│   브라우저/앱 ─── (HTTPS) ─── MCPHUB ─── MCP Server (원격)      │
│   - 네트워크 통해 어디서든 접근                                 │
│   - 인증/인가 처리 필요                                         │
│   - SSE로 실시간 스트리밍 가능                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

[다음: 게이트웨이 →](./4.게이트웨이.md)
